# Intel Intrinsics## CHM documentationThis project builds a C# command-line app that parses Intel’s documentation into the developer-friendly CHM format.The code quality is mediocre, because I don’t care: I only need the output.You’ll find the compiled CHM file [on “Releases” page](https://github.com/Const-me/IntelIntrinsics/releases).If the fonts are too small for you, [here’s a fix](https://superuser.com/a/204783/31483).If you aren’t using Windows and don’t have HTML help viewer application, rename the .chm to .zip, unpack the content from “html” subfolder, and open “misc\_All.html”, “misc\_Categories.html” or “misc\_Technologies.html” page in a web browser.You won’t have index nor search, but it’s still usable this way.## C++ WrappersI’ve made a first version some time ago, and since that time I’ve been using the documentation extensively while working on my C++ code.After using these intrinsics for a couple of years, some issues started to annoy me.1. The worst of all, there’s no compile-time platform checks.Because of this, it’s very easy to accidentally use e.g. SSSE3 intrinsic in the code, and introduce fatal crash “invalid instruction” on a customer’s PC who’s using old AMD CPU that doesn’t support supplementary SSE3.2. The API is C. This means no namespaces and type prefixes everywhere, no overloaded operators, no templates. When used wisely, these features make code easier to both read and write.3. Some names like`_mm_srli_epi16` are non-obvious, you can probably figure out that it’s right bit shift, but for the difference between that and `_mm_sra_epi16` you’ll have to read the documentation i.e. loose time.At some point I’ve realized Intel’s documentation XML contains enough information to solve these problems. And because of this CHM documentation project, I already parse the XML into machine-readable representation.So, this project now builds a set of C++ wrappers around SIMD intrinsics. All problems in computer science can be solved by another level of abstraction.The generated wrappers make a header-only library, with a bunch of inline C++ functions. Everything should be inlined i.e. this extra layer of abstractions is zero cost.It solves #1 because wrapped functions are grouped in different header files by technology. Unless you include ssse3.hpp header, calls to APIs like abs_epi32() won’t compile.It solves #2 by replacing prefixes with C++ namespaces. This allows some degree of metaprogramming, i.e. the same “max_ps” function call can be compiled to SSE instruction to process 4 values, or to AVX instruction to process 8 values. n each file, intrinsics are grouped to namespaces by register size, i.e. “avx2.hpp” header contains two namespaces, “Intrinsics::Avx” with AVX2 intrinsics processing 32 bytes registers, and “Intrinsics::Sse” with AVX2 intrinsics processing 16 bytes registers.Additionally, the library overloads some operators for these vector datatypes.It doesn’t solve #3 completely, but it helps by including documentation comments in the header files. Some IDEs show the comment in tool tip. All IDEs have “go to definition” command.That single lines of comment look simple but they makes it easier to write SIMD code.