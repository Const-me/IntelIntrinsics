# FAQ## Why SIMD?It’s the only way to approach advertised performance figures of all CPU newer than 10-15 years.For example, `Avx::fmadd_ps` can run 2 times per clock, and it multiplies+adds 8 floating point values, that’s [32 FLOPS/cycle](https://stackoverflow.com/a/15657772/126995)## Why not automatic vectorization?Based on my experience, compilers can only vectorize very simple code.## Why not wrapper classes?Wrappers work well for graphics code because it mostly needs Vector3f, Vector4f and arrays of them.CPU instructions working on integer SIMD registers can process 8, 16, 32, and 64-bit lanes, some of them are signed other unsigned, and some of them use saturated math.Not all combinations are supported for every operation/data type. This makes it very hard to design good API.## Why Intel-assigned names, why not rename `srli_epi16` to `shiftRightInt16` or `operator >>`?With original names it’s easier to use documentation or search for answers.And there's not enough operators in C++. For example, C++ only has one `operator +` but some add operations are supported in both traditional (wraps on overflow) and saturated (sticks to min/max on overflow) variants.## Why there’s no vector dot product or matrix multiplication?There’s already a good library for that, [Microsoft DirectXMath](https://github.com/Microsoft/DirectXMath), with MIT license.Microsoft’s XMVECTOR is a typedef for the same `__m128` native data type, so the interop is seamless.## Why there’s no AVX512 support?I don’t have AVX512 hardware to test the result.## What do these wrappers do?Most of them do nothing, just call the original intrinsics. There're couple of exceptions.* `set_xxx` argument order is flipped so it's now correct. For example, `Sse::set_epi32( 1, 2, 3, 4 )` will make a register with `[ 1, 2, 3, 4 ]` values.<br />`setr_xxx` is removed.* Implemented additional `set_xxx` and `set1_xxx` for unsigned integer types, e.g. `set1_epu16(uint16_t)` and `Sse::set_epu64x(uint64_t, uint64_t)`.* Renamed a few intrinsics, e.g. `_mm256_broadcastq_epi64` is exposed as `Avx::broadcast_epi64`, without the 'q'.<br />Also, integer operations processing complete registers, such as `_mm_and_si128` and `_mm256_or_si256` have their suffix replaced with "all", i.e. they are exposed as `Sse::and_all` and `Avx::or_all`.* Immediate arguments are converted to C++ template arguments.* Implemented a few template-based shuffle functions.